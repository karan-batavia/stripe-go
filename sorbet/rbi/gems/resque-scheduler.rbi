# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/resque-scheduler/all/resque-scheduler.rbi
#
# resque-scheduler-4.5.0

module Resque
  extend Resque::Scheduler::Extension
end
module Resque::Scheduler
  def self.am_master; end
  def self.app_str; end
  def self.before_shutdown; end
  def self.build_procline(string); end
  def self.clear_schedule!; end
  def self.enqueue(config); end
  def self.enqueue_delayed_items_for_timestamp(timestamp); end
  def self.enqueue_from_config(job_config); end
  def self.enqueue_next_item(timestamp); end
  def self.enqueue_recurring(name, config); end
  def self.env_matches?(configured_env); end
  def self.env_str; end
  def self.failure_handler; end
  def self.failure_handler=(arg0); end
  def self.handle_delayed_items(at_time = nil); end
  def self.handle_shutdown; end
  def self.handle_signals_with_operation; end
  def self.internal_name; end
  def self.load_schedule!; end
  def self.load_schedule_job(name, config); end
  def self.log!(msg); end
  def self.log(msg); end
  def self.log_error(msg); end
  def self.logger; end
  def self.logger=(arg0); end
  def self.optionizate_interval_value(value); end
  def self.poll_sleep; end
  def self.poll_sleep_loop; end
  def self.print_schedule; end
  def self.procline(string); end
  def self.rails_env_matches?(config); end
  def self.reload_schedule!; end
  def self.rufus_scheduler; end
  def self.run; end
  def self.scheduled_jobs; end
  def self.shutdown; end
  def self.stop_rufus_scheduler; end
  def self.unschedule_job(name); end
  def self.update_schedule; end
  extend Resque::Scheduler::Configuration
  extend Resque::Scheduler::Locking
  extend Resque::Scheduler::SignalHandling
end
module Resque::Scheduler::Configuration
  def app_name; end
  def app_name=(arg0); end
  def configure; end
  def dynamic; end
  def dynamic=(arg0); end
  def env; end
  def env=(arg0); end
  def logfile; end
  def logfile=(arg0); end
  def logformat; end
  def logformat=(arg0); end
  def poll_sleep_amount; end
  def poll_sleep_amount=(arg0); end
  def quiet; end
  def quiet=(arg0); end
  def verbose; end
  def verbose=(arg0); end
end
module Resque::Scheduler::Lock
end
class Resque::Scheduler::Lock::Base
  def acquire!; end
  def extend_lock!; end
  def hostname; end
  def initialize(key, options = nil); end
  def key; end
  def locked?; end
  def process_id; end
  def release!; end
  def release; end
  def timeout; end
  def timeout=(arg0); end
  def value; end
end
class Resque::Scheduler::Lock::Basic < Resque::Scheduler::Lock::Base
  def acquire!; end
  def locked?; end
end
class Resque::Scheduler::Lock::Resilient < Resque::Scheduler::Lock::Base
  def acquire!; end
  def acquire_sha(refresh = nil); end
  def evalsha(script, keys, argv, refresh: nil); end
  def locked?; end
  def locked_sha(refresh = nil); end
  def timeout=(seconds); end
end
module Resque::Scheduler::Locking
  def build_master_lock; end
  def master?; end
  def master_lock; end
  def master_lock_key; end
  def redis_master_version; end
  def release_master_lock!; end
  def release_master_lock; end
  def supports_lua?; end
end
class Resque::Scheduler::LoggerBuilder
  def build; end
  def initialize(opts = nil); end
  def json_formatter; end
  def level; end
  def text_formatter; end
end
module Resque::Scheduler::SignalHandling
  def handle_signals; end
  def register_signal_handlers; end
  def signal_queue; end
  def signal_queue=(arg0); end
end
class Resque::Scheduler::FailureHandler
  def self.on_enqueue_failure(_, e); end
end
module Resque::Scheduler::SchedulingExtensions
  def all_schedules; end
  def fetch_schedule(name); end
  def non_persistent_schedules; end
  def persistent_schedules; end
  def prepare_schedules(schedule_hash); end
  def reload_schedule!; end
  def remove_schedule(name, reload = nil); end
  def schedule; end
  def schedule=(schedule_hash); end
  def set_schedule(name, config, reload = nil); end
end
module Resque::Scheduler::Plugin
  def self.hooks(job, pattern); end
  def self.run_after_schedule_hooks(klass, *args); end
  def self.run_before_delayed_enqueue_hooks(klass, *args); end
  def self.run_before_schedule_hooks(klass, *args); end
  def self.run_hooks(job, pattern, *args); end
end
module Resque::Scheduler::DelayingExtensions
  def clean_up_timestamp(key, timestamp); end
  def count_all_scheduled_jobs; end
  def delayed?(klass, *args); end
  def delayed_push(timestamp, item); end
  def delayed_queue_peek(start, count); end
  def delayed_queue_schedule_size; end
  def delayed_timestamp_peek(timestamp, start, count); end
  def delayed_timestamp_size(timestamp); end
  def enqueue_at(timestamp, klass, *args); end
  def enqueue_at_with_queue(queue, timestamp, klass, *args); end
  def enqueue_delayed(klass, *args); end
  def enqueue_delayed_selection(klass = nil); end
  def enqueue_delayed_with_queue(klass, queue, *args); end
  def enqueue_in(number_of_seconds_from_now, klass, *args); end
  def enqueue_in_with_queue(queue, number_of_seconds_from_now, klass, *args); end
  def find_delayed_selection(klass = nil, &block); end
  def get_last_enqueued_at(job_name); end
  def job_to_hash(klass, args); end
  def job_to_hash_with_queue(queue, klass, args); end
  def last_enqueued_at(job_name, date); end
  def next_delayed_timestamp(at_time = nil); end
  def next_item_for_timestamp(timestamp); end
  def payload_matches_selection?(decoded_payload, klass); end
  def plugin; end
  def remove_delayed(klass, *args); end
  def remove_delayed_in_queue(klass, queue, *args); end
  def remove_delayed_job(encoded_job); end
  def remove_delayed_job_from_timestamp(timestamp, klass, *args); end
  def remove_delayed_selection(klass = nil); end
  def reset_delayed_queue; end
  def scheduled_at(klass, *args); end
  def search_first_delayed_timestamp_in_range(start_at, stop_at); end
end
module Resque::Scheduler::Extension
  include Resque::Scheduler::DelayingExtensions
  include Resque::Scheduler::SchedulingExtensions
end
module Resque::Scheduler::Server
  def self.included(base); end
end
module Resque::Scheduler::Server::ServerMethods
  def delayed; end
  def delayed_cancel_now; end
  def delayed_clear; end
  def delayed_jobs_klass; end
  def delayed_queue_now; end
  def delayed_search; end
  def delayed_timestamp; end
  def delete_schedule; end
  def schedule; end
  def schedule_requeue; end
  def schedule_requeue_with_params; end
end
module Resque::Scheduler::Server::HelperMethods
  def delayed_jobs_for_worker(_worker); end
  def find_job(worker); end
  def format_time(t); end
  def queue_from_class_name(class_name); end
  def rails_env(name); end
  def schedule_class(config); end
  def schedule_interval(config); end
  def schedule_interval_every(every); end
  def scheduled_in_this_env?(name); end
  def scheduler_template(name); end
  def scheduler_view(filename, options = nil, locals = nil); end
  def show_job_arguments(args); end
  def working_jobs_for_worker(worker); end
end
class Resque::Server < Sinatra::Base
  include Resque::Scheduler::Server
  include Resque::Scheduler::Server::HelperMethods
  include Resque::Scheduler::Server::ServerMethods
end
