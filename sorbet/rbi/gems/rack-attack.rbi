# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rack-attack/all/rack-attack.rbi
#
# rack-attack-6.5.0

module Rack
end
class Rack::Attack
  def call(env); end
  def configuration; end
  def initialize(app); end
  def self.blocklist(*args, &block); end
  def self.blocklist_ip(*args, &block); end
  def self.blocklisted_response(*args, &block); end
  def self.blocklisted_response=(*args, &block); end
  def self.blocklists(*args, &block); end
  def self.cache; end
  def self.clear!; end
  def self.clear_configuration(*args, &block); end
  def self.configuration; end
  def self.enabled; end
  def self.enabled=(arg0); end
  def self.instrument(request); end
  def self.notifier; end
  def self.notifier=(arg0); end
  def self.reset!; end
  def self.safelist(*args, &block); end
  def self.safelist_ip(*args, &block); end
  def self.safelists(*args, &block); end
  def self.throttle(*args, &block); end
  def self.throttle_discriminator_normalizer; end
  def self.throttle_discriminator_normalizer=(arg0); end
  def self.throttled_response(*args, &block); end
  def self.throttled_response=(*args, &block); end
  def self.throttled_response_retry_after_header(*args, &block); end
  def self.throttled_response_retry_after_header=(*args, &block); end
  def self.throttles(*args, &block); end
  def self.track(*args, &block); end
  def self.tracks(*args, &block); end
end
class Rack::Attack::Cache
  def count(unprefixed_key, period); end
  def delete(unprefixed_key); end
  def do_count(key, expires_in); end
  def enforce_store_method_presence!(method_name); end
  def enforce_store_presence!; end
  def initialize; end
  def key_and_expiry(unprefixed_key, period); end
  def last_epoch_time; end
  def prefix; end
  def prefix=(arg0); end
  def read(unprefixed_key); end
  def reset!; end
  def reset_count(unprefixed_key, period); end
  def store; end
  def store=(store); end
  def write(unprefixed_key, value, expires_in); end
end
class Rack::Attack::Configuration
  def anonymous_blocklists; end
  def anonymous_safelists; end
  def blocklist(name = nil, &block); end
  def blocklist_ip(ip_address); end
  def blocklisted?(request); end
  def blocklisted_response; end
  def blocklisted_response=(arg0); end
  def blocklists; end
  def clear_configuration; end
  def initialize; end
  def safelist(name = nil, &block); end
  def safelist_ip(ip_address); end
  def safelisted?(request); end
  def safelists; end
  def set_defaults; end
  def throttle(name, options, &block); end
  def throttled?(request); end
  def throttled_response; end
  def throttled_response=(arg0); end
  def throttled_response_retry_after_header; end
  def throttled_response_retry_after_header=(arg0); end
  def throttles; end
  def track(name, options = nil, &block); end
  def tracked?(request); end
end
module Rack::Attack::FallbackPathNormalizer
  def self.normalize_path(path); end
end
class Rack::Attack::Request < Rack::Request
end
class Rack::Attack::BaseProxy < SimpleDelegator
  def self.handle?(_store); end
  def self.inherited(klass); end
  def self.lookup(store); end
  def self.proxies; end
end
module Rack::Attack::StoreProxy
end
class Rack::Attack::StoreProxy::DalliProxy < Rack::Attack::BaseProxy
  def delete(key); end
  def increment(key, amount, options = nil); end
  def initialize(client); end
  def read(key); end
  def rescuing; end
  def self.handle?(store); end
  def stub_with_if_missing; end
  def write(key, value, options = nil); end
end
class Rack::Attack::StoreProxy::MemCacheStoreProxy < Rack::Attack::BaseProxy
  def self.handle?(store); end
  def write(name, value, options = nil); end
end
class Rack::Attack::StoreProxy::RedisProxy < Rack::Attack::BaseProxy
  def delete(key, _options = nil); end
  def delete_matched(matcher, _options = nil); end
  def increment(key, amount, options = nil); end
  def initialize(*args); end
  def read(key); end
  def rescuing; end
  def self.handle?(store); end
  def write(key, value, options = nil); end
end
class Rack::Attack::StoreProxy::RedisStoreProxy < Rack::Attack::StoreProxy::RedisProxy
  def read(key); end
  def self.handle?(store); end
  def write(key, value, options = nil); end
end
class Rack::Attack::StoreProxy::RedisCacheStoreProxy < Rack::Attack::BaseProxy
  def increment(name, amount = nil, **options); end
  def read(name, options = nil); end
  def self.handle?(store); end
  def write(name, value, options = nil); end
end
class Rack::Attack::StoreProxy::ActiveSupportRedisStoreProxy < Rack::Attack::BaseProxy
  def increment(name, amount = nil, options = nil); end
  def read(name, options = nil); end
  def self.handle?(store); end
  def write(name, value, options = nil); end
end
class Rack::Attack::Railtie < Rails::Railtie
end
class Rack::Attack::Error < StandardError
end
class Rack::Attack::MisconfiguredStoreError < Rack::Attack::Error
end
class Rack::Attack::MissingStoreError < Rack::Attack::Error
end
class Rack::Attack::IncompatibleStoreError < Rack::Attack::Error
end
class Rack::Attack::Throttle
  def annotate_request_with_matched_data(request, data); end
  def annotate_request_with_throttle_data(request, data); end
  def block; end
  def cache; end
  def discriminator_for(request); end
  def initialize(name, options, &block); end
  def limit; end
  def limit_for(request); end
  def matched_by?(request); end
  def name; end
  def period; end
  def period_for(request); end
  def type; end
end
