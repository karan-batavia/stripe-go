# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/resque/all/resque.rbi
#
# resque-2.1.0

module Resque
  def after_fork(&block); end
  def after_fork=(block); end
  def after_pause(&block); end
  def after_pause=(block); end
  def before_first_fork(&block); end
  def before_first_fork=(block); end
  def before_fork(&block); end
  def before_fork=(block); end
  def before_pause(&block); end
  def before_pause=(block); end
  def classify(dashed_word); end
  def clear_hooks(name); end
  def constantize(camel_cased_word); end
  def data_store; end
  def decode(object); end
  def dequeue(klass, *args); end
  def encode(object); end
  def enqueue(klass, *args); end
  def enqueue_front; end
  def enqueue_front=(arg0); end
  def enqueue_to(queue, klass, *args); end
  def heartbeat_interval; end
  def heartbeat_interval=(arg0); end
  def hooks(name); end
  def info; end
  def inline; end
  def inline=(arg0); end
  def inline?; end
  def keys; end
  def list_range(key, start = nil, count = nil); end
  def logger; end
  def logger=(arg0); end
  def peek(queue, start = nil, count = nil); end
  def pop(queue); end
  def prune_interval; end
  def prune_interval=(arg0); end
  def push(queue, item); end
  def queue_empty(&block); end
  def queue_empty=(block); end
  def queue_from_class(klass); end
  def queue_sizes; end
  def queues; end
  def redis; end
  def redis=(server); end
  def redis_id; end
  def register_hook(name, block); end
  def remove_queue(queue); end
  def remove_worker(worker_id); end
  def reserve(queue); end
  def sample_queues(sample_size = nil); end
  def size(queue); end
  def stat_data_store; end
  def stat_data_store=(stat_data_store); end
  def to_s; end
  def validate(klass, queue = nil); end
  def watch_queue(queue); end
  def worker_exit(&block); end
  def worker_exit=(block); end
  def workers; end
  def working; end
  extend Forwardable
  extend Resque
  include Resque::Helpers
end
class Resque::NoQueueError < RuntimeError
end
class Resque::NoClassError < RuntimeError
end
class Resque::DirtyExit < RuntimeError
  def initialize(message = nil, process_status = nil); end
  def process_status; end
end
class Resque::PruneDeadWorkerDirtyExit < Resque::DirtyExit
  def initialize(hostname, job); end
end
class Resque::TermException < SignalException
end
module Resque::Failure
  def self.all(offset = nil, limit = nil, queue = nil); end
  def self.backend; end
  def self.backend=(backend); end
  def self.clear(queue = nil); end
  def self.count(queue = nil, class_name = nil); end
  def self.create(options = nil); end
  def self.each(offset = nil, limit = nil, queue = nil, class_name = nil, order = nil, &block); end
  def self.failure_queue_name(job_queue_name); end
  def self.job_queue_name(failure_queue_name); end
  def self.queues; end
  def self.remove(id, queue = nil); end
  def self.remove_queue(queue); end
  def self.requeue(id, queue = nil); end
  def self.requeue_all; end
  def self.requeue_queue(queue); end
  def self.url; end
end
class Resque::Failure::Base
  def exception; end
  def exception=(arg0); end
  def initialize(exception, worker, queue, payload); end
  def log(message); end
  def payload; end
  def payload=(arg0); end
  def queue; end
  def queue=(arg0); end
  def save; end
  def self.all(offset = nil, limit = nil, queue = nil); end
  def self.clear(*args); end
  def self.count(queue = nil, class_name = nil); end
  def self.each(*args); end
  def self.queues; end
  def self.remove(*args); end
  def self.requeue(*args); end
  def self.url; end
  def worker; end
  def worker=(arg0); end
end
module Resque::Helpers
  def classify(dashed_word); end
  def constantize(camel_cased_word); end
  def decode(object); end
  def encode(object); end
  def redis; end
end
class Resque::Helpers::DecodeException < StandardError
end
module Resque::Stat
  def <<(stat); end
  def >>(stat); end
  def [](stat); end
  def clear(stat); end
  def data_store; end
  def data_store=(data_store); end
  def decr(stat, by = nil); end
  def get(stat); end
  def incr(stat, by = nil); end
  def redis; end
  extend Resque::Stat
end
module Resque::Logging
  def debug(message); end
  def error(message); end
  def fatal(message); end
  def info(message); end
  def self.debug(message); end
  def self.error(message); end
  def self.fatal(message); end
  def self.info(message); end
  def self.log(severity, message); end
  def self.warn(message); end
  def warn(message); end
end
class Resque::QuietFormatter
  def call(serverity, datetime, progname, msg); end
end
class Resque::VerboseFormatter
  def call(serverity, datetime, progname, msg); end
end
class Resque::VeryVerboseFormatter
  def call(serverity, datetime, progname, msg); end
end
class Resque::Job
  def ==(other); end
  def after_hooks; end
  def args; end
  def around_hooks; end
  def before_hooks; end
  def classify(dashed_word); end
  def constantize(camel_cased_word); end
  def data_store; end
  def decode(object); end
  def encode(object); end
  def fail(exception); end
  def failure_hooks; end
  def has_payload_class?; end
  def initialize(queue, payload); end
  def inspect; end
  def payload; end
  def payload_class; end
  def payload_class_name; end
  def perform; end
  def queue; end
  def recreate; end
  def redis; end
  def run_failure_hooks(exception); end
  def self.create(queue, klass, *args); end
  def self.data_store; end
  def self.decode(object); end
  def self.destroy(queue, klass, *args); end
  def self.encode(object); end
  def self.redis; end
  def self.reserve(queue); end
  def worker; end
  def worker=(arg0); end
  extend Resque::Helpers
  include Resque::Helpers
end
class Resque::Job::DontPerform < StandardError
end
class Resque::Worker
  def ==(other); end
  def child_already_exited?; end
  def data_store; end
  def decode(object); end
  def done_working; end
  def enable_gc_optimizations; end
  def encode(object); end
  def failed!; end
  def failed; end
  def fork_per_job=(arg0); end
  def fork_per_job?; end
  def glob_match(list, pattern); end
  def graceful_term; end
  def graceful_term=(arg0); end
  def heartbeat!(time = nil); end
  def heartbeat; end
  def hostname; end
  def hostname=(arg0); end
  def id; end
  def idle?; end
  def initialize(*queues); end
  def inspect; end
  def job(reload = nil); end
  def job=(arg0); end
  def kill_background_threads; end
  def kill_child; end
  def linux_worker_pids; end
  def log!(message); end
  def log(message); end
  def log_with_severity(severity, message); end
  def new_kill_child; end
  def pause_processing; end
  def paused?; end
  def perform(job); end
  def perform_with_fork(job, &block); end
  def pid; end
  def pid=(arg0); end
  def pre_shutdown_timeout; end
  def pre_shutdown_timeout=(arg0); end
  def prepare; end
  def process(job = nil, &block); end
  def processed!; end
  def processed; end
  def processing(reload = nil); end
  def procline(string); end
  def prune_dead_workers; end
  def queues; end
  def queues=(queues); end
  def reconnect; end
  def redis; end
  def register_signal_handlers; end
  def register_worker; end
  def remove_heartbeat; end
  def report_failed_job(job, exception); end
  def reserve; end
  def run_at_exit_hooks; end
  def run_at_exit_hooks=(arg0); end
  def run_hook(name, *args); end
  def self.all; end
  def self.all_heartbeats; end
  def self.all_workers_with_expired_heartbeats; end
  def self.attach(worker_id); end
  def self.data_store; end
  def self.exists?(worker_id); end
  def self.find(worker_id, options = nil); end
  def self.kill_all_heartbeat_threads; end
  def self.redis; end
  def self.working; end
  def shutdown!; end
  def shutdown; end
  def shutdown?; end
  def solaris_worker_pids; end
  def start_heartbeat; end
  def started!; end
  def started; end
  def startup; end
  def state; end
  def state_change; end
  def term_child; end
  def term_child=(arg0); end
  def term_child_signal; end
  def term_child_signal=(arg0); end
  def term_timeout; end
  def term_timeout=(arg0); end
  def to_s; end
  def to_s=(arg0); end
  def unpause_processing; end
  def unregister_signal_handlers; end
  def unregister_worker(exception = nil); end
  def validate_queues; end
  def verbose; end
  def verbose=(value); end
  def very_verbose; end
  def very_verbose=(value); end
  def wait_for_child_exit(timeout); end
  def windows_worker_pids; end
  def work(interval = nil, &block); end
  def work_one_job(job = nil, &block); end
  def worker_pids; end
  def working?; end
  def working_on(job); end
  extend Resque::Helpers
  include Resque::Helpers
  include Resque::Logging
end
module Resque::Plugin
  def after_dequeue_hooks(job); end
  def after_enqueue_hooks(job); end
  def after_hooks(job); end
  def around_hooks(job); end
  def before_dequeue_hooks(job); end
  def before_enqueue_hooks(job); end
  def before_hooks(job); end
  def failure_hooks(job); end
  def get_hook_names(job, hook_method_prefix); end
  def job_methods(job); end
  def lint(plugin); end
  extend Resque::Plugin
end
class Resque::Plugin::LintError < RuntimeError
end
class Resque::DataStore
  def acquire_pruning_dead_worker_lock(*args, &block); end
  def add_failed_queue(*args, &block); end
  def all_heartbeats(*args, &block); end
  def all_resque_keys; end
  def clear_failed_queue(*args, &block); end
  def clear_stat(*args, &block); end
  def decrement_stat(*args, &block); end
  def decremet_stat(*args); end
  def everything_in_queue(*args, &block); end
  def failed_queue_names(*args, &block); end
  def get_worker_payload(*args, &block); end
  def heartbeat!(*args, &block); end
  def heartbeat(*args, &block); end
  def identifier; end
  def increment_stat(*args, &block); end
  def initialize(redis); end
  def list_range(*args, &block); end
  def method_missing(sym, *args, &block); end
  def num_failed(*args, &block); end
  def peek_in_queue(*args, &block); end
  def pop_from_queue(*args, &block); end
  def push_to_failed_queue(*args, &block); end
  def push_to_queue(*args, &block); end
  def queue_names(*args, &block); end
  def queue_size(*args, &block); end
  def reconnect; end
  def register_worker(*args, &block); end
  def remove_failed_queue(*args, &block); end
  def remove_from_failed_queue(*args, &block); end
  def remove_from_queue(*args, &block); end
  def remove_heartbeat(*args, &block); end
  def remove_queue(*args, &block); end
  def respond_to?(method, include_all = nil); end
  def server_time; end
  def set_worker_payload(*args, &block); end
  def stat(*args, &block); end
  def unregister_worker(*args, &block); end
  def update_item_in_failed_queue(*args, &block); end
  def watch_queue(*args, &block); end
  def worker_done_working(*args, &block); end
  def worker_exists?(*args, &block); end
  def worker_ids(*args, &block); end
  def worker_start_time(*args, &block); end
  def worker_started(*args, &block); end
  def workers_map(*args, &block); end
  extend Forwardable
end
class Resque::DataStore::QueueAccess
  def everything_in_queue(queue); end
  def initialize(redis); end
  def list_range(key, start = nil, count = nil); end
  def peek_in_queue(queue, start = nil, count = nil); end
  def pop_from_queue(queue); end
  def push_to_queue(queue, encoded_item); end
  def queue_names; end
  def queue_size(queue); end
  def redis_key_for_queue(queue); end
  def remove_from_queue(queue, data); end
  def remove_queue(queue); end
  def watch_queue(queue); end
end
class Resque::DataStore::FailedQueueAccess
  def add_failed_queue(failed_queue_name); end
  def clear_failed_queue(failed_queue_name = nil); end
  def failed_queue_names(find_queue_names_in_key = nil); end
  def initialize(redis); end
  def num_failed(failed_queue_name = nil); end
  def push_to_failed_queue(data, failed_queue_name = nil); end
  def remove_failed_queue(failed_queue_name = nil); end
  def remove_from_failed_queue(index_in_failed_queue, failed_queue_name = nil); end
  def update_item_in_failed_queue(index_in_failed_queue, new_item_data, failed_queue_name = nil); end
end
class Resque::DataStore::Workers
  def acquire_pruning_dead_worker_lock(worker, expiry); end
  def all_heartbeats; end
  def get_worker_payload(worker_id); end
  def heartbeat!(worker, time); end
  def heartbeat(worker); end
  def initialize(redis); end
  def redis_key_for_worker(worker); end
  def redis_key_for_worker_pruning; end
  def redis_key_for_worker_start_time(worker); end
  def register_worker(worker); end
  def remove_heartbeat(worker); end
  def set_worker_payload(worker, data); end
  def unregister_worker(worker, &block); end
  def worker_done_working(worker, &block); end
  def worker_exists?(worker_id); end
  def worker_ids; end
  def worker_start_time(worker); end
  def worker_started(worker); end
  def workers_map(worker_ids); end
end
class Resque::DataStore::StatsAccess
  def clear_stat(stat); end
  def decremet_stat(stat, by = nil); end
  def increment_stat(stat, by = nil); end
  def initialize(redis); end
  def stat(stat); end
end
class Resque::ThreadSignal
  def initialize; end
  def signal; end
  def wait_for_signal(timeout); end
end
module UTF8Util
  def self.clean!(str); end
  def self.clean(str); end
end
class Resque::Railtie < Rails::Railtie
end
class Resque::Failure::Multiple < Resque::Failure::Base
  def initialize(*args); end
  def save; end
  def self.all(*args); end
  def self.classes; end
  def self.classes=(arg0); end
  def self.clear(*args); end
  def self.configure; end
  def self.count(*args); end
  def self.each(*args, &block); end
  def self.queues; end
  def self.remove(index, queue = nil); end
  def self.requeue(*args); end
  def self.requeue_all; end
  def self.requeue_queue(queue); end
  def self.url; end
end
class Resque::Server < Sinatra::Base
  def class_if_current(path = nil); end
  def current_page; end
  def current_section; end
  def failed_class_counts(queue = nil); end
  def failed_date_format; end
  def failed_end_at; end
  def failed_multiple_queues?; end
  def failed_order; end
  def failed_per_page; end
  def failed_size; end
  def failed_start_at; end
  def h(string); end
  def page_entries_info(start, stop, size, name = nil); end
  def partial(template, local_vars = nil); end
  def partial?; end
  def path_prefix; end
  def poll; end
  def redis_get_size(key); end
  def redis_get_value_as_array(key, start = nil); end
  def resque; end
  def self.app_file; end
  def self.app_file=(val); end
  def self.app_file?; end
  def self.public_folder; end
  def self.public_folder=(val); end
  def self.public_folder?; end
  def self.static; end
  def self.static=(val); end
  def self.static?; end
  def self.tabs; end
  def self.url_prefix; end
  def self.url_prefix=(url_prefix); end
  def self.views; end
  def self.views=(val); end
  def self.views?; end
  def show(page, layout = nil); end
  def show_args(args); end
  def show_for_polling(page); end
  def tab(name); end
  def tabs; end
  def u(*path_parts); end
  def url_path(*path_parts); end
  def url_prefix; end
  def worker_hosts!; end
  def worker_hosts; end
  include Rack::Utils
end
