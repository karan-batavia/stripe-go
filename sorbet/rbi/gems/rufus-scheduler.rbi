# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rufus-scheduler/all/rufus-scheduler.rbi
#
# rufus-scheduler-3.6.0

module Rufus
end
class Rufus::Scheduler
  def at(time, callable = nil, opts = nil, &block); end
  def at_jobs(opts = nil); end
  def confirm_lock; end
  def cron(cronline, callable = nil, opts = nil, &block); end
  def cron_jobs(opts = nil); end
  def do_schedule(job_type, t, callable, opts, return_job_instance, block); end
  def down?; end
  def every(duration, callable = nil, opts = nil, &block); end
  def every_jobs(opts = nil); end
  def fetch(job_or_job_id); end
  def frequency; end
  def frequency=(arg0); end
  def in(duration, callable = nil, opts = nil, &block); end
  def in_jobs(opts = nil); end
  def initialize(opts = nil); end
  def interval(duration, callable = nil, opts = nil, &block); end
  def interval_jobs(opts = nil); end
  def job(job_id); end
  def jobs(opts = nil); end
  def join; end
  def join_all_work_threads; end
  def kill_all_work_threads; end
  def lock; end
  def max_work_threads; end
  def max_work_threads=(arg0); end
  def mutexes; end
  def occurrences(time0, time1, format = nil); end
  def on_error(job, err); end
  def pause; end
  def paused?; end
  def repeat(arg, callable = nil, opts = nil, &block); end
  def resume; end
  def running_jobs(opts = nil); end
  def schedule(arg, callable = nil, opts = nil, &block); end
  def schedule_at(time, callable = nil, opts = nil, &block); end
  def schedule_cron(cronline, callable = nil, opts = nil, &block); end
  def schedule_every(duration, callable = nil, opts = nil, &block); end
  def schedule_in(duration, callable = nil, opts = nil, &block); end
  def schedule_interval(duration, callable = nil, opts = nil, &block); end
  def scheduled?(job_or_job_id); end
  def self.h_to_s(t = nil); end
  def self.parse(o, opts = nil); end
  def self.parse_at(o, opts = nil); end
  def self.parse_cron(o, opts); end
  def self.parse_duration(str, opts = nil); end
  def self.parse_in(o, opts = nil); end
  def self.s(opts = nil); end
  def self.singleton(opts = nil); end
  def self.start_new; end
  def self.to_duration(seconds, options = nil); end
  def self.to_duration_hash(seconds, options = nil); end
  def self.to_fugit_duration(seconds, options = nil); end
  def self.utc_to_s(t = nil); end
  def shutdown(opt = nil); end
  def start; end
  def started_at; end
  def stderr; end
  def stderr=(arg0); end
  def stop(opt = nil); end
  def terminate_all_jobs; end
  def thread; end
  def thread_key; end
  def threads; end
  def timeline(time0, time1); end
  def timeout_jobs; end
  def trigger_jobs; end
  def unlock; end
  def unschedule(job_or_job_id); end
  def unschedule_jobs; end
  def up?; end
  def uptime; end
  def uptime_s; end
  def work_queue; end
  def work_threads(query = nil); end
end
class Rufus::Scheduler::D
  def self.h_to_s(t = nil); end
end
class Rufus::Scheduler::Job
  def [](key); end
  def []=(key, value); end
  def call(do_rescue = nil); end
  def callable; end
  def callback(meth, time); end
  def check_frequency; end
  def compute_timeout; end
  def count; end
  def do_call(time, do_rescue); end
  def do_trigger(time); end
  def handler; end
  def id; end
  def initialize(scheduler, original, opts, block); end
  def job_id; end
  def key?(key); end
  def keys; end
  def kill; end
  def last_time; end
  def last_work_time; end
  def mean_work_time; end
  def mutex(m); end
  def next_time; end
  def next_time=(arg0); end
  def next_times(count); end
  def opts; end
  def original; end
  def post_trigger(time); end
  def previous_time; end
  def previous_time=(arg0); end
  def running?; end
  def scheduled?; end
  def scheduled_at; end
  def start_work_thread; end
  def tags; end
  def threads; end
  def trigger(time); end
  def trigger_now(time); end
  def trigger_off_schedule(time = nil); end
  def trigger_queue(time); end
  def unschedule; end
  def unscheduled_at; end
end
class Rufus::Scheduler::Job::KillSignal < StandardError
end
class Rufus::Scheduler::OneTimeJob < Rufus::Scheduler::Job
  def determine_id; end
  def occurrences(time0, time1); end
  def set_next_time(trigger_time, is_post = nil); end
  def time; end
end
class Rufus::Scheduler::AtJob < Rufus::Scheduler::OneTimeJob
  def initialize(scheduler, time, opts, block); end
end
class Rufus::Scheduler::InJob < Rufus::Scheduler::OneTimeJob
  def initialize(scheduler, duration, opts, block); end
end
class Rufus::Scheduler::RepeatJob < Rufus::Scheduler::Job
  def determine_id; end
  def first_at; end
  def first_at=(first); end
  def initialize(scheduler, duration, opts, block); end
  def last_at; end
  def last_at=(last); end
  def next_times(count); end
  def occurrences(time0, time1); end
  def pause; end
  def paused?; end
  def paused_at; end
  def resume; end
  def times; end
  def times=(arg0); end
  def trigger(time); end
end
class Rufus::Scheduler::EvInJob < Rufus::Scheduler::RepeatJob
  def first_at=(first); end
end
class Rufus::Scheduler::EveryJob < Rufus::Scheduler::EvInJob
  def check_frequency; end
  def frequency; end
  def initialize(scheduler, duration, opts, block); end
  def next_time_from(time); end
  def set_next_time(trigger_time, is_post = nil); end
end
class Rufus::Scheduler::IntervalJob < Rufus::Scheduler::EvInJob
  def initialize(scheduler, interval, opts, block); end
  def interval; end
  def next_time_from(time); end
  def set_next_time(trigger_time, is_post = nil); end
end
class Rufus::Scheduler::CronJob < Rufus::Scheduler::RepeatJob
  def brute_frequency; end
  def check_frequency; end
  def cron_line; end
  def initialize(scheduler, cronline, opts, block); end
  def next_time_from(time); end
  def rough_frequency; end
  def set_next_time(trigger_time, is_post = nil); end
end
class Rufus::Scheduler::JobArray
  def [](job_id); end
  def array; end
  def delete_unscheduled; end
  def each(now, &block); end
  def initialize; end
  def push(job); end
  def size; end
  def to_a; end
end
class Rufus::Scheduler::NullLock
  def lock; end
  def locked?; end
  def unlock; end
end
class Rufus::Scheduler::FileLock
  def initialize(path); end
  def lock; end
  def locked?; end
  def path; end
  def unlock; end
end
class Rufus::Scheduler::Error < StandardError
end
class Rufus::Scheduler::TimeoutError < Rufus::Scheduler::Error
end
class Rufus::Scheduler::NotRunningError < Rufus::Scheduler::Error
end
