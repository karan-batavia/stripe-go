# frozen_string_literal: true
# typed: true

require_relative '../test_helper'

class Critic::OrderAmendmentTranslation < Critic::FunctionalTest
  before do
    @user = make_user(save: true)
  end

  def create_contract_from_order(sf_order)
    sf.update!(SF_ORDER, {
      SF_ID => sf_order.Id,
      SF_ORDER_CONTRACTED => true,
    })

    # the contracted order puts the ID on the contract itself
    # this operation executes async in SF, so we need to wait for the contract to be created

    related_contracts = T.let(nil, T.untyped)

    wait_until do
      related_contracts = sf.query("SELECT Id FROM #{SF_CONTRACT} WHERE SBQQ__Order__c = '#{sf_order.Id}'")
      related_contracts.count > 0
    end

    assert_equal(1, related_contracts.count)

    sf_contract = sf_get(related_contracts.first.Id)
  end

  # this API is tricky: requires empty JSON object and Content-Type set correctly
  def create_quote_data_from_contract_amendment(sf_contract)
    JSON.parse(sf.patch("services/apexrest/SBQQ/ServiceRouter?loader=SBQQ.ContractManipulationAPI.ContractAmender&uid=#{sf_contract.Id}", {}, {"Content-Type" => "application/json"}).body)
  end

  def create_order_from_quote_data(sf_quote_data)
    sf_quote_id = calculate_and_save_cpq_quote(sf_quote_data)

    # the amendment quote process doesn't seem to pick a pricebook, so we need to manually do this
    sf.update!(CPQ_QUOTE, {
      SF_ID => sf_quote_id,
      CPQ_QUOTE_PRICEBOOK => default_pricebook_id,
    })

    create_order_from_cpq_quote(sf_quote_id)
  end

  it 'creates a new phase from an order amendment with monthly billed products' do
    sf_order = create_subscription_order
    sf_contract = create_contract_from_order(sf_order)

    # api precondition: initial orders have a nil contract ID
    sf_order.refresh
    assert_nil(sf_order.ContractId)

    # the contract should reference the initial order that was created
    assert_equal(sf_order[SF_ID], sf_contract[SF_CONTRACT_ORDER_ID])

    amendment_data = create_quote_data_from_contract_amendment(sf_contract)

    # increase quantity
    amendment_data["lineItems"].first["record"]["SBQQ__Quantity__c"] = 3

    # the quote is generated by the contract CPQ API, so we need to set these fields manually
    # let's have the second phase start in 9mo
    start_date = now_time + 9.months
    end_date = start_date + 3.months
    initial_start_date = now_time

    amendment_data["record"][CPQ_QUOTE_SUBSCRIPTION_START_DATE] = start_date.strftime("%Y-%m-%d")
    amendment_data["record"][CPQ_QUOTE_SUBSCRIPTION_TERM] = 3

    sf_order_amendment = create_order_from_quote_data(amendment_data)

    # api preconditions: the contract ID on the amendment is STILL empty right after the contract is created
    assert_nil(sf_order_amendment.ContractId)
    refute(sf_order_amendment[SF_ORDER_CONTRACTED])

    # https://help.salesforce.com/s/articleView?id=cpq_amend_contracts.htm&type=5&language=en_US
    # "The amendment opportunity updates its Amended Contract and Primary Quote fields with links to the contract you amended and your original quote."
    sf_amendment_opportunity = sf_get(sf_order_amendment.OpportunityId)
    assert_equal(sf_amendment_opportunity.SBQQ__AmendedContract__c, sf_contract.Id)

    # confirmed with users that they contract order amendments
    sf_order_amendment_contract = create_contract_from_order(sf_order_amendment)
    # contracting the order amendment links it to the same contract object
    assert_equal(sf_order_amendment_contract.Id, sf_contract.Id)
    # the quote reference seems to stay the same
    assert_equal(sf_order_amendment_contract[SF_CONTRACT_QUOTE_ID], sf_contract[SF_CONTRACT_QUOTE_ID])
    # however, the order reference on the contract is updated as well!
    refute_equal(sf_order_amendment_contract[SF_CONTRACT_ORDER_ID], sf_contract[SF_CONTRACT_ORDER_ID])

    StripeForce::Translate.perform_inline(@user, sf_order_amendment.Id)

    sf_order.refresh
    stripe_id = sf_order[prefixed_stripe_field(GENERIC_STRIPE_ID)]

    subscription_schedule = Stripe::SubscriptionSchedule.retrieve(stripe_id, @user.stripe_credentials)

    assert_equal(2, subscription_schedule.phases.count)

    first_phase = T.must(subscription_schedule.phases.first)
    second_phase = T.must(subscription_schedule.phases[1])

    # first phase should have one item with a quantity of one
    assert_equal(1, first_phase.items.count)
    assert_equal(0, first_phase.add_invoice_items.count)
    first_phase_item = T.must(first_phase.items.first)
    assert_equal(1, first_phase_item.quantity)

    # first phase should start now and end in 9mo
    assert_equal(0, first_phase.start_date - initial_start_date.to_i)
    assert_equal(0, first_phase.end_date - start_date.to_i)

    # second phase should start at the end date
    assert_equal(0, second_phase.start_date - start_date.to_i)
    assert_equal(0, second_phase.end_date - end_date.to_i)

    # second phase should have a second item with a quantity of 3
    # the order line in SF will have 2 (added 2 to have a net quantity of 3)
    assert_equal(1, second_phase.items.count)
    assert_equal(0, second_phase.add_invoice_items.count)
    second_phase_item = T.must(second_phase.items.first)
    assert_equal(3, second_phase_item.quantity)

    # prices should be the same, but the order line reference is different
    # NOTE if proration is set to day, the pricing will be customized and this check will fail
    # TODO this check is failing due to a possibly-incorrect way we are structuring pricing
    # assert_equal(first_phase_item.price, second_phase_item.price)
    refute_equal(first_phase_item.metadata['salesforce_order_item_id'], second_phase_item.metadata['salesforce_order_item_id'])
  end

  # usage products do NOT have a quantity in Stripe, which introduces additional complexity
  it 'creates a new phase from an order amendment with monthly usage billed products' do
    amendment_term = 6
    initial_start_date = now_time
    amendment_start_date = initial_start_date + 6.months
    amendment_end_date = amendment_start_date + amendment_term.months

    sf_metered_product_id, sf_metered_pricebook_id = salesforce_recurring_metered_produce_with_price
    sf_product_id, sf_pricebook_id = salesforce_recurring_product_with_price

    sf_order = create_subscription_order(sf_product_id: sf_metered_product_id)
    sf_contract = create_contract_from_order(sf_order)

    amendment_data = create_quote_data_from_contract_amendment(sf_contract)

    # remove metered billing item completely
    amendment_data["lineItems"].first["record"]["SBQQ__Quantity__c"] = 0

    amendment_data["record"][CPQ_QUOTE_SUBSCRIPTION_START_DATE] = amendment_start_date.strftime("%Y-%m-%d")
    amendment_data["record"][CPQ_QUOTE_SUBSCRIPTION_TERM] = amendment_term

    sf_quote_id = calculate_and_save_cpq_quote(amendment_data)

    amendment_data = add_product_to_cpq_quote(sf_quote_id, sf_product_id: sf_product_id)

    sf_order_amendment = create_order_from_quote_data(amendment_data)

    StripeForce::Translate.perform_inline(@user, sf_order_amendment.Id)

    sf_order.refresh
    stripe_id = sf_order[prefixed_stripe_field(GENERIC_STRIPE_ID)]

    subscription_schedule = Stripe::SubscriptionSchedule.retrieve(stripe_id, @user.stripe_credentials)

    assert_equal(2, subscription_schedule.phases.count)

    first_phase = T.must(subscription_schedule.phases.first)
    second_phase = T.must(subscription_schedule.phases[1])

    # first phase should have one item with no quantity, since it is a metered product
    assert_equal(1, first_phase.items.count)
    assert_equal(0, first_phase.add_invoice_items.count)
    first_phase_item = T.must(first_phase.items.first)
    assert_nil(first_phase_item[:quantity])

    # first phase should start now and end in 9mo
    assert_equal(0, first_phase.start_date - initial_start_date.to_i)
    assert_equal(0, first_phase.end_date - amendment_start_date.to_i)

    # second phase should start at the end date
    assert_equal(0, second_phase.start_date - amendment_start_date.to_i)
    assert_equal(0, second_phase.end_date - amendment_end_date.to_i)

    # second phase should have a second item with a quantity of 1
    assert_equal(2, second_phase.items.count)
    assert_equal(0, second_phase.add_invoice_items.count)
    metered_billing_item = T.must(second_phase.items.detect {|i| i[:quantity].nil? })
    subscription_item = T.must(second_phase.items.detect {|i| !i[:quantity].nil? })
    assert_equal(1, subscription_item.quantity)

    # prices should be the same, but the order line reference is different
    # NOTE if proration is set to day, the pricing will be customized and this check will fail
    # TODO this check is failing due to a possibly-incorrect way we are structuring pricing
    assert_equal(first_phase_item.price, metered_billing_item.price)
    refute_equal(first_phase_item.metadata['salesforce_order_item_id'], subscription_item.metadata['salesforce_order_item_id'])
  end

  it 'creates a new phase with a duration equal to billing frequency' do
    start_date = now_time + 12.months
    amendment_term = 12
    end_date = start_date + amendment_term.months
    initial_start_date = now_time

    sf_product_id, sf_pricebook_id = salesforce_recurring_product_with_price(
      additional_product_fields: {
        CPQ_QUOTE_BILLING_FREQUENCY => CPQBillingFrequencyOptions::ANNUAL.serialize,
        CPQ_QUOTE_SUBSCRIPTION_TERM => nil,
      }
    )

    sf_order = create_salesforce_order(
      sf_product_id: sf_product_id,
      additional_quote_fields: {
        CPQ_QUOTE_SUBSCRIPTION_START_DATE => initial_start_date.strftime("%Y-%m-%d"),
        # 2yr term, two billing cycles
        CPQ_QUOTE_SUBSCRIPTION_TERM => 24.0,
      }
    )

    sf_contract = create_contract_from_order(sf_order)
    amendment_data = create_quote_data_from_contract_amendment(sf_contract)

    # increase quantity
    amendment_data["lineItems"].first["record"]["SBQQ__Quantity__c"] = 3

    amendment_data["record"][CPQ_QUOTE_SUBSCRIPTION_START_DATE] = start_date.strftime("%Y-%m-%d")
    amendment_data["record"][CPQ_QUOTE_SUBSCRIPTION_TERM] = amendment_term

    sf_order_amendment = create_order_from_quote_data(amendment_data)
    sf_order_amendment_contract = create_contract_from_order(sf_order_amendment)

    StripeForce::Translate.perform_inline(@user, sf_order_amendment.Id)

    sf_order.refresh
    stripe_id = sf_order[prefixed_stripe_field(GENERIC_STRIPE_ID)]
    subscription_schedule = Stripe::SubscriptionSchedule.retrieve(stripe_id, @user.stripe_credentials)

    assert_equal(2, subscription_schedule.phases.count)

    first_phase = T.must(subscription_schedule.phases.first)
    second_phase = T.must(subscription_schedule.phases[1])

    # first phase should start now and end in 9mo
    assert_equal(0, first_phase.start_date - initial_start_date.to_i)
    assert_equal(0, first_phase.end_date - start_date.to_i)

    # second phase should start at the end date
    assert_equal(0, second_phase.start_date - start_date.to_i)
    assert_equal(0, second_phase.end_date - end_date.to_i)

    assert_equal(1, first_phase.items.count)
    assert_equal(1, second_phase.items.count)

    first_phase_item = T.must(first_phase.items.first)
    second_phase_item = T.must(second_phase.items.first)

    assert_equal(1, first_phase_item.quantity)
    assert_equal(3, second_phase_item.quantity)

    # price should be identical
    assert_equal(first_phase_item.price, second_phase_item.price)
  end

  it 'creates a new phase with a duration shorter than the billing frequency' do
    skip("full order proration support is needed here since iterations will be 1, which will extend the contract longer than it should")

    start_date = now_time + 18.months
    amendment_term = 6
    end_date = start_date + amendment_term.months
    initial_start_date = now_time

    sf_product_id, sf_pricebook_id = salesforce_recurring_product_with_price(
      additional_product_fields: {
        CPQ_QUOTE_BILLING_FREQUENCY => CPQBillingFrequencyOptions::ANNUAL.serialize,
      }
    )

    sf_order = create_salesforce_order(
      sf_product_id: sf_product_id,
      additional_quote_fields: {
        CPQ_QUOTE_SUBSCRIPTION_START_DATE => initial_start_date.strftime("%Y-%m-%d"),
        # 2yr term, two billing cycles
        CPQ_QUOTE_SUBSCRIPTION_TERM => 24.0,
      }
    )

    sf_contract = create_contract_from_order(sf_order)
    amendment_data = create_quote_data_from_contract_amendment(sf_contract)

    # increase quantity
    amendment_data["lineItems"].first["record"]["SBQQ__Quantity__c"] = 3

    amendment_data["record"][CPQ_QUOTE_SUBSCRIPTION_START_DATE] = start_date.strftime("%Y-%m-%d")
    amendment_data["record"][CPQ_QUOTE_SUBSCRIPTION_TERM] = amendment_term

    sf_order_amendment = create_order_from_quote_data(amendment_data)
    sf_order_amendment_contract = create_contract_from_order(sf_order_amendment)

    StripeForce::Translate.perform_inline(@user, sf_order_amendment.Id)

    sf_order.refresh
    stripe_id = sf_order[prefixed_stripe_field(GENERIC_STRIPE_ID)]
    subscription_schedule = Stripe::SubscriptionSchedule.retrieve(stripe_id, @user.stripe_credentials)

    assert_equal(2, subscription_schedule.phases.count)

    first_phase = T.must(subscription_schedule.phases.first)
    second_phase = T.must(subscription_schedule.phases[1])

    # first phase should start now and end in 9mo
    assert_equal(0, first_phase.start_date - initial_start_date.to_i)
    assert_equal(0, first_phase.end_date - start_date.to_i)

    # second phase should start at the end date
    assert_equal(0, second_phase.start_date - start_date.to_i)
    assert_equal(0, second_phase.end_date - end_date.to_i)

    assert_equal(1, first_phase.items.count)
    assert_equal(1, second_phase.items.count)

    first_phase_item = T.must(first_phase.items.first)
    second_phase_item = T.must(second_phase.items.first)

    assert_equal(1, first_phase_item.quantity)
    assert_equal(3, second_phase_item.quantity)

    # price should NOT be identical since it's a shorter duration!
    # assert_equal(first_phase_item.price, second_phase_item.price)
  end

  it 'cancels a subscription in the future' do
    sf_order = create_subscription_order

    StripeForce::Translate.perform_inline(@user, sf_order.Id)

    sf_order.refresh
    stripe_id = sf_order[prefixed_stripe_field(GENERIC_STRIPE_ID)]

    original_subscription_schedule = Stripe::SubscriptionSchedule.retrieve(stripe_id, @user.stripe_credentials)

    sf_contract = create_contract_from_order(sf_order)

    # api precondition: initial orders have a nil contract ID
    sf_order.refresh
    assert_nil(sf_order.ContractId)

    # the contract should reference the initial order that was created
    assert_equal(sf_order[SF_ID], sf_contract[SF_CONTRACT_ORDER_ID])

    amendment_data = create_quote_data_from_contract_amendment(sf_contract)

    # wipe out the product
    amendment_data["lineItems"].first["record"]["SBQQ__Quantity__c"] = 0

    # the quote is generated by the contract CPQ API, so we need to set these fields manually
    # let's have the second phase start in 9mo
    end_date = (now_time + 9.months)
    amendment_data["record"][CPQ_QUOTE_SUBSCRIPTION_START_DATE] = format_date_for_salesforce(end_date)
    amendment_data["record"][CPQ_QUOTE_SUBSCRIPTION_TERM] = 3

    sf_order_amendment = create_order_from_quote_data(amendment_data)
    assert_equal(sf_order_amendment.Type, OrderTypeOptions::AMENDMENT.serialize)

    StripeForce::Translate.perform_inline(@user, sf_order_amendment.Id)

    sf_order.refresh
    stripe_id = sf_order[prefixed_stripe_field(GENERIC_STRIPE_ID)]

    subscription_schedule = Stripe::SubscriptionSchedule.retrieve(stripe_id, @user.stripe_credentials)

    assert_equal(1, subscription_schedule.phases.count)

    # make sure the end date is modified to match the end date of the amendment
    phase = T.must(subscription_schedule.phases.first)
    assert_equal(0, end_date.to_i - phase.end_date)
    assert_equal(0, phase.start_date - now_time.to_i)

    assert_equal(1, phase.items.count)
    assert_equal(0, phase.add_invoice_items.count)
    phase_item = T.must(phase.items.first)
    assert_equal(1, phase_item.quantity)

    original_subscription_phase = T.must(original_subscription_schedule.phases.first)
    excluded_comparison_fields = %i{metadata end_date}
    assert_equal(
      original_subscription_phase.to_hash.reject {|k, _v| excluded_comparison_fields.include?(k) },
      phase.to_hash.reject {|k, _v| excluded_comparison_fields.include?(k) },
      "outside of metadata and end_date the original subscription and terminated subscription should be equal"
    )
  end

  # use case: user decides *right* after signing the contract they want to change their order competely
  it 'cancels a subscription on the same day' do
    sf_order = create_subscription_order

    StripeForce::Translate.perform_inline(@user, sf_order.Id)

    sf_contract = create_contract_from_order(sf_order)

    # the contract should reference the initial order that was created
    assert_equal(sf_order[SF_ID], sf_contract[SF_CONTRACT_ORDER_ID])

    amendment_data = create_quote_data_from_contract_amendment(sf_contract)

    # wipe out the product
    amendment_data["lineItems"].first["record"]["SBQQ__Quantity__c"] = 0

    # the quote is generated by the contract CPQ API, so we need to set these fields manually
    # let's have the second phase start in 9mo
    # end_date = (DateTime.now.utc.beginning_of_day + 9.months)
    amendment_data["record"][CPQ_QUOTE_SUBSCRIPTION_START_DATE] = now_time_formatted_for_salesforce
    amendment_data["record"][CPQ_QUOTE_SUBSCRIPTION_TERM] = 12

    sf_order_amendment = create_order_from_quote_data(amendment_data)
    assert_equal(sf_order_amendment.Type, OrderTypeOptions::AMENDMENT.serialize)

    StripeForce::Translate.perform_inline(@user, sf_order_amendment.Id)

    sf_order.refresh
    stripe_id = sf_order[prefixed_stripe_field(GENERIC_STRIPE_ID)]
    subscription_schedule = Stripe::SubscriptionSchedule.retrieve(stripe_id, @user.stripe_credentials)

    # TODO is there anything else we need to do when we cancel a subscription schedule? Something with the invoices or subscription?
    assert_equal('canceled', subscription_schedule.status)
  end

  # this can occur if contracts are created async and the apex jobs are backed up
  # in this case, we'll just process the initial order we have without pulling the contract
  it 'does not fail if a contract does not yet exist for an order' do
    sf_order = create_subscription_order
    sf_contract = create_contract_from_order(sf_order)

    sf.destroy(SF_CONTRACT, sf_contract.Id)

    StripeForce::Translate.perform_inline(@user, sf_order.Id)
  end

  it 'customized prices on the line level' do

  end

  it 'adding new product' do

  end

  it 'removing a product' do

  end

  it 'uses metadata on the original line item if an item is not removed' do

  end

  it 'supports adding one-off line items on a order amendment' do

  end

  describe 'metadata' do
    it 'pulls metadata from each order amendment to the phase of each subscription'
  end

  describe 'errors' do
    it 'creates a sync error when MISSING FIELDS' do

    end
  end


end
