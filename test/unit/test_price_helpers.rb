# frozen_string_literal: true
# typed: true
require_relative '../test_helper'

module Critic::Unit
  class PriceHelpersTest < Critic::UnitTest
    describe '#pricing_tiers_equal?' do
      # https://jira.corp.stripe.com/browse/PLATINT-1817
      it 'handles different ordering of tiers' do
        price_1 = Stripe::Price.construct_from({
          id: "price_1LalAnCM3YxTUEmtSIWT580H",
          object: "price",
          active: false,
          billing_scheme: "tiered",
          created: 1661453581,
          currency: "usd",
          custom_unit_amount: nil,
          livemode: false,
          lookup_key: nil,
          metadata: {},
          nickname: nil,
          product: "prod_LfIYek0p06aEF8",
          recurring: {aggregate_usage: nil,
                      interval: "month",
                      interval_count: 1,
                      trial_period_days: nil,
                      usage_type: "metered",},
          tax_behavior: "unspecified",
          tiers: [{flat_amount: 0,
                   flat_amount_decimal: "0",
                   unit_amount: nil,
                   unit_amount_decimal: nil,
                   up_to: 11,},
                  {flat_amount: nil,
                   flat_amount_decimal: nil,
                   unit_amount: 2537,
                   unit_amount_decimal: "2537",
                   up_to: nil,},],
          tiers_mode: "graduated",
          transform_quantity: nil,
          type: "recurring",
          unit_amount: nil,
          unit_amount_decimal: nil,
        })

        price_2 = Stripe::Price.construct_from({
          billing_scheme: "tiered",
          currency: "usd",
          product: "prod_LfIYek0p06aEF8",
          recurring: {aggregate_usage: nil,
                      interval: "month",
                      interval_count: 1,
                      trial_period_days: nil,
                      usage_type: "metered",},
          tax_behavior: "unspecified",
          tiers: [
            # NOTE tier ordering is flipped!
            {flat_amount: nil,
             flat_amount_decimal: nil,
             unit_amount: 2537,
             unit_amount_decimal: "2537",
             up_to: nil,},

            {flat_amount: 0,
             flat_amount_decimal: "0",
             unit_amount: nil,
             unit_amount_decimal: nil,
             up_to: 11,},
          ],
          tiers_mode: "graduated",
          transform_quantity: nil,
          type: "recurring",
          unit_amount: nil,
          unit_amount_decimal: nil,
        })

        assert(StripeForce::Translate::PriceHelpers.pricing_tiers_equal?(price_1, price_2))
      end

      it 'handles flat_amount_decimal as string or decimal' do
        # generated by the connector
        price_1 = Stripe::Price.construct_from({
          tiers: [
            {
              flat_amount_decimal: BigDecimal("0"),
              up_to: 20,
            },
            {
              unit_amount_decimal: BigDecimal("2129"),
              up_to: "inf",
            },
          ],
        })

        # pre-exisitng stripe price
        price_2 = Stripe::Price.construct_from({
          tiers: [
            {
              flat_amount: 0,
              flat_amount_decimal: "0",
              unit_amount: nil,
              unit_amount_decimal: nil,
              up_to: 20,
            },
            {
              flat_amount: nil,
              flat_amount_decimal: nil,
              unit_amount: 2129,
              unit_amount_decimal: "2129",
              up_to: nil,
            },
          ],
        })

        assert(StripeForce::Translate::PriceHelpers.pricing_tiers_equal?(price_1, price_2))
      end

      it 'handles flat_amount comparison between integern and bigdecimal' do
        # generated by the connector
        price_1 = Stripe::Price.construct_from({
          tiers: [
            {
              flat_amount: BigDecimal("0"),
              up_to: 20,
            },
            {
              unit_amount: BigDecimal("2129"),
              up_to: "inf",
            },
          ],
        })

        # pre-existing stripe price
        price_2 = Stripe::Price.construct_from({
          tiers: [
            {
              flat_amount: 0,
              unit_amount: nil,
              up_to: 20,
            },
            {
              flat_amount: nil,
              unit_amount: 2129,
              up_to: nil,
            },
          ],
        })

        assert(StripeForce::Translate::PriceHelpers.pricing_tiers_equal?(price_1, price_2))
      end
    end

    describe '#price_billing_amounts_equal?' do
      it 'prices are not treated as equal if currencies do not match' do
        price_1 = Stripe::Price.construct_from({
          id: "price_1LkAdSIsgf92XbAOR0IC4XkV",
          object: "price",
          billing_scheme: "per_unit",
          currency: "eur",
          product: "prod_MT6r0AWW02Zj6K",
          recurring: nil,
          tax_behavior: "unspecified",
          tiers_mode: nil,
          type: "one_time",
          unit_amount: 12000,
          unit_amount_decimal: "12000",
        })

        price_2 = Stripe::Price.construct_from({
          currency: "usd",
          unit_amount_decimal: BigDecimal("12000.0"),
          recurring: {},
        })

        refute(StripeForce::Translate::PriceHelpers.price_billing_amounts_equal?(price_1, price_2))
      end

      it 'properly compares one time prices when they are not equal' do
        price_1 = Stripe::Price.construct_from({
          id: "price_1LkAdSIsgf92XbAOR0IC4XkV",
          object: "price",
          billing_scheme: "per_unit",
          currency: "usd",
          product: "prod_MT6r0AWW02Zj6K",
          recurring: nil,
          tax_behavior: "unspecified",
          tiers_mode: nil,
          type: "one_time",
          unit_amount: 12000,
          unit_amount_decimal: "12000",
        })

        price_2 = Stripe::Price.construct_from({
          currency: "usd",
          unit_amount_decimal: BigDecimal("12100.0"),
          recurring: {},
        })

        refute(StripeForce::Translate::PriceHelpers.price_billing_amounts_equal?(price_1, price_2))
      end

      it 'properly compares one time prices when they are equal' do
        price_1 = Stripe::Price.construct_from({
          id: "price_1LkAdSIsgf92XbAOR0IC4XkV",
          object: "price",
          active: true,
          billing_scheme: "per_unit",
          created: 1663696410,
          currency: "usd",
          custom_unit_amount: nil,
          livemode: false,
          lookup_key: nil,
          metadata: {salesforce_pricebook_entry_id: "01u0R00000KMmNyQAL", salesforce_pricebook_entry_link: "https://force-java-9147-dev-ed.my.salesforce.com/01u0R00000KMmNyQAL"},
          nickname: nil,
          product: "prod_MT6r0AWW02Zj6K",
          recurring: nil,
          tax_behavior: "unspecified",
          tiers_mode: nil,
          transform_quantity: nil,
          type: "one_time",
          unit_amount: 12000,
          unit_amount_decimal: "12000",
        })

        price_2 = Stripe::Price.construct_from({
          currency: "usd",
          unit_amount_decimal: BigDecimal("12000.0"),
          recurring: {},
        })

        assert(StripeForce::Translate::PriceHelpers.price_billing_amounts_equal?(price_1, price_2))
      end
    end

    describe '#using_custom_order_line_price_field' do
      it 'detects if a custom pricing field is not used' do
        user = make_user
        refute(StripeForce::Translate::PriceHelpers.using_custom_order_line_price_field?(user))
      end

      it 'detects if a custom pricing is used' do
        user = make_user
        user.field_mappings = {
          'price_order_item' => {
            'unit_amount_decimal' => 'SomethingCustomField',
          },
        }

        assert(StripeForce::Translate::PriceHelpers.using_custom_order_line_price_field?(user))
      end
    end
  end
end
